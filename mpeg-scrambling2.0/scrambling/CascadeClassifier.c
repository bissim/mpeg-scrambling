/* CascadeClassifier.c generated by valac 0.38.4-dirty, the Vala compiler
 * generated from CascadeClassifier.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>


#define CLASSIFIER_TYPE_CASCADE_CLASSIFIER (classifier_cascade_classifier_get_type ())
#define CLASSIFIER_CASCADE_CLASSIFIER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CLASSIFIER_TYPE_CASCADE_CLASSIFIER, classifierCascadeClassifier))
#define CLASSIFIER_CASCADE_CLASSIFIER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CLASSIFIER_TYPE_CASCADE_CLASSIFIER, classifierCascadeClassifierClass))
#define CLASSIFIER_IS_CASCADE_CLASSIFIER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CLASSIFIER_TYPE_CASCADE_CLASSIFIER))
#define CLASSIFIER_IS_CASCADE_CLASSIFIER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CLASSIFIER_TYPE_CASCADE_CLASSIFIER))
#define CLASSIFIER_CASCADE_CLASSIFIER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CLASSIFIER_TYPE_CASCADE_CLASSIFIER, classifierCascadeClassifierClass))

typedef struct _classifierCascadeClassifier classifierCascadeClassifier;
typedef struct _classifierCascadeClassifierClass classifierCascadeClassifierClass;
typedef struct _classifierCascadeClassifierPrivate classifierCascadeClassifierPrivate;
enum  {
	CLASSIFIER_CASCADE_CLASSIFIER_0_PROPERTY,
	CLASSIFIER_CASCADE_CLASSIFIER_NUM_PROPERTIES
};
static GParamSpec* classifier_cascade_classifier_properties[CLASSIFIER_CASCADE_CLASSIFIER_NUM_PROPERTIES];

#define GEOMETRY_TYPE_MAT (geometry_mat_get_type ())
#define GEOMETRY_MAT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEOMETRY_TYPE_MAT, geometryMat))
#define GEOMETRY_MAT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEOMETRY_TYPE_MAT, geometryMatClass))
#define GEOMETRY_IS_MAT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEOMETRY_TYPE_MAT))
#define GEOMETRY_IS_MAT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEOMETRY_TYPE_MAT))
#define GEOMETRY_MAT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEOMETRY_TYPE_MAT, geometryMatClass))

typedef struct _geometryMat geometryMat;
typedef struct _geometryMatClass geometryMatClass;

#define GEOMETRY_TYPE_MAT_OF_RECT (geometry_mat_of_rect_get_type ())
#define GEOMETRY_MAT_OF_RECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEOMETRY_TYPE_MAT_OF_RECT, geometryMatOfRect))
#define GEOMETRY_MAT_OF_RECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEOMETRY_TYPE_MAT_OF_RECT, geometryMatOfRectClass))
#define GEOMETRY_IS_MAT_OF_RECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEOMETRY_TYPE_MAT_OF_RECT))
#define GEOMETRY_IS_MAT_OF_RECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEOMETRY_TYPE_MAT_OF_RECT))
#define GEOMETRY_MAT_OF_RECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEOMETRY_TYPE_MAT_OF_RECT, geometryMatOfRectClass))

typedef struct _geometryMatOfRect geometryMatOfRect;
typedef struct _geometryMatOfRectClass geometryMatOfRectClass;
typedef struct _geometryMatPrivate geometryMatPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _classifierCascadeClassifier {
	GObject parent_instance;
	classifierCascadeClassifierPrivate * priv;
	glong nativeObj;
};

struct _classifierCascadeClassifierClass {
	GObjectClass parent_class;
};

struct _geometryMat {
	GObject parent_instance;
	geometryMatPrivate * priv;
	glong nativeObj;
};

struct _geometryMatClass {
	GObjectClass parent_class;
};


static gpointer classifier_cascade_classifier_parent_class = NULL;

GType classifier_cascade_classifier_get_type (void) G_GNUC_CONST;
classifierCascadeClassifier* classifier_cascade_classifier_new (void);
classifierCascadeClassifier* classifier_cascade_classifier_construct (GType object_type);
glong classifier_cascade_classifier_CascadeClassifier_1 (void);
gboolean classifier_cascade_classifier_load (classifierCascadeClassifier* self, const gchar* filename);
gboolean classifier_cascade_classifier_load_0 (glong nativeObj, const gchar* filename);
GType geometry_mat_get_type (void) G_GNUC_CONST;
GType geometry_mat_of_rect_get_type (void) G_GNUC_CONST;
void classifier_cascade_classifier_detectMultiScale (classifierCascadeClassifier* self, geometryMat* image, geometryMatOfRect* objects);
void classifier_cascade_classifier_detectMultiScale_1 (glong nativeObj, glong image_nativeObj, glong objects_mat_nativeObj);
static void classifier_cascade_classifier_finalize (GObject * obj);


classifierCascadeClassifier* classifier_cascade_classifier_construct (GType object_type) {
	classifierCascadeClassifier * self = NULL;
	glong _tmp0_;
	self = (classifierCascadeClassifier*) g_object_new (object_type, NULL);
	_tmp0_ = classifier_cascade_classifier_CascadeClassifier_1 ();
	self->nativeObj = _tmp0_;
	return self;
	return self;
}


classifierCascadeClassifier* classifier_cascade_classifier_new (void) {
	return classifier_cascade_classifier_construct (CLASSIFIER_TYPE_CASCADE_CLASSIFIER);
}


gboolean classifier_cascade_classifier_load (classifierCascadeClassifier* self, const gchar* filename) {
	gboolean result = FALSE;
	gboolean retVal = FALSE;
	glong _tmp0_;
	const gchar* _tmp1_;
	gboolean _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (filename != NULL, FALSE);
	_tmp0_ = self->nativeObj;
	_tmp1_ = filename;
	_tmp2_ = classifier_cascade_classifier_load_0 (_tmp0_, _tmp1_);
	retVal = _tmp2_;
	result = retVal;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void classifier_cascade_classifier_detectMultiScale (classifierCascadeClassifier* self, geometryMat* image, geometryMatOfRect* objects) {
	geometryMat* objects_mat = NULL;
	geometryMatOfRect* _tmp0_;
	geometryMat* _tmp1_;
	glong _tmp2_;
	geometryMat* _tmp3_;
	glong _tmp4_;
	glong _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (image != NULL);
	g_return_if_fail (objects != NULL);
	_tmp0_ = objects;
	_tmp1_ = _g_object_ref0 ((geometryMat*) _tmp0_);
	objects_mat = _tmp1_;
	_tmp2_ = self->nativeObj;
	_tmp3_ = image;
	_tmp4_ = _tmp3_->nativeObj;
	_tmp5_ = objects_mat->nativeObj;
	classifier_cascade_classifier_detectMultiScale_1 (_tmp2_, _tmp4_, _tmp5_);
	_g_object_unref0 (objects_mat);
	return;
}


static void classifier_cascade_classifier_class_init (classifierCascadeClassifierClass * klass) {
	classifier_cascade_classifier_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = classifier_cascade_classifier_finalize;
}


static void classifier_cascade_classifier_instance_init (classifierCascadeClassifier * self) {
}


static void classifier_cascade_classifier_finalize (GObject * obj) {
	classifierCascadeClassifier * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, CLASSIFIER_TYPE_CASCADE_CLASSIFIER, classifierCascadeClassifier);
	G_OBJECT_CLASS (classifier_cascade_classifier_parent_class)->finalize (obj);
}


GType classifier_cascade_classifier_get_type (void) {
	static volatile gsize classifier_cascade_classifier_type_id__volatile = 0;
	if (g_once_init_enter (&classifier_cascade_classifier_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (classifierCascadeClassifierClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) classifier_cascade_classifier_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (classifierCascadeClassifier), 0, (GInstanceInitFunc) classifier_cascade_classifier_instance_init, NULL };
		GType classifier_cascade_classifier_type_id;
		classifier_cascade_classifier_type_id = g_type_register_static (G_TYPE_OBJECT, "classifierCascadeClassifier", &g_define_type_info, 0);
		g_once_init_leave (&classifier_cascade_classifier_type_id__volatile, classifier_cascade_classifier_type_id);
	}
	return classifier_cascade_classifier_type_id__volatile;
}



