/* OpenCVFaceDetector.c generated by valac 0.38.4-dirty, the Vala compiler
 * generated from OpenCVFaceDetector.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>


#define COM_FACEDETECT_TYPE_FACE_DETECTOR_INTERFACE (com_facedetect_face_detector_interface_get_type ())
#define COM_FACEDETECT_FACE_DETECTOR_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), COM_FACEDETECT_TYPE_FACE_DETECTOR_INTERFACE, comfacedetectFaceDetectorInterface))
#define COM_FACEDETECT_IS_FACE_DETECTOR_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), COM_FACEDETECT_TYPE_FACE_DETECTOR_INTERFACE))
#define COM_FACEDETECT_FACE_DETECTOR_INTERFACE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), COM_FACEDETECT_TYPE_FACE_DETECTOR_INTERFACE, comfacedetectFaceDetectorInterfaceIface))

typedef struct _comfacedetectFaceDetectorInterface comfacedetectFaceDetectorInterface;
typedef struct _comfacedetectFaceDetectorInterfaceIface comfacedetectFaceDetectorInterfaceIface;

#define COM_FACEDETECT_STRATEGIES_TYPE_OPEN_CV_FACE_DETECTOR (com_facedetect_strategies_open_cv_face_detector_get_type ())
#define COM_FACEDETECT_STRATEGIES_OPEN_CV_FACE_DETECTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), COM_FACEDETECT_STRATEGIES_TYPE_OPEN_CV_FACE_DETECTOR, comfacedetectstrategiesOpenCVFaceDetector))
#define COM_FACEDETECT_STRATEGIES_OPEN_CV_FACE_DETECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), COM_FACEDETECT_STRATEGIES_TYPE_OPEN_CV_FACE_DETECTOR, comfacedetectstrategiesOpenCVFaceDetectorClass))
#define COM_FACEDETECT_STRATEGIES_IS_OPEN_CV_FACE_DETECTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), COM_FACEDETECT_STRATEGIES_TYPE_OPEN_CV_FACE_DETECTOR))
#define COM_FACEDETECT_STRATEGIES_IS_OPEN_CV_FACE_DETECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), COM_FACEDETECT_STRATEGIES_TYPE_OPEN_CV_FACE_DETECTOR))
#define COM_FACEDETECT_STRATEGIES_OPEN_CV_FACE_DETECTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), COM_FACEDETECT_STRATEGIES_TYPE_OPEN_CV_FACE_DETECTOR, comfacedetectstrategiesOpenCVFaceDetectorClass))

typedef struct _comfacedetectstrategiesOpenCVFaceDetector comfacedetectstrategiesOpenCVFaceDetector;
typedef struct _comfacedetectstrategiesOpenCVFaceDetectorClass comfacedetectstrategiesOpenCVFaceDetectorClass;
typedef struct _comfacedetectstrategiesOpenCVFaceDetectorPrivate comfacedetectstrategiesOpenCVFaceDetectorPrivate;
enum  {
	COM_FACEDETECT_STRATEGIES_OPEN_CV_FACE_DETECTOR_0_PROPERTY,
	COM_FACEDETECT_STRATEGIES_OPEN_CV_FACE_DETECTOR_NUM_PROPERTIES
};
static GParamSpec* com_facedetect_strategies_open_cv_face_detector_properties[COM_FACEDETECT_STRATEGIES_OPEN_CV_FACE_DETECTOR_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define GEOMETRY_TYPE_RECTANGLE (geometry_rectangle_get_type ())
#define GEOMETRY_RECTANGLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEOMETRY_TYPE_RECTANGLE, geometryRectangle))
#define GEOMETRY_RECTANGLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEOMETRY_TYPE_RECTANGLE, geometryRectangleClass))
#define GEOMETRY_IS_RECTANGLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEOMETRY_TYPE_RECTANGLE))
#define GEOMETRY_IS_RECTANGLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEOMETRY_TYPE_RECTANGLE))
#define GEOMETRY_RECTANGLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEOMETRY_TYPE_RECTANGLE, geometryRectangleClass))

typedef struct _geometryRectangle geometryRectangle;
typedef struct _geometryRectangleClass geometryRectangleClass;

#define CLASSIFIER_TYPE_CASCADE_CLASSIFIER (classifier_cascade_classifier_get_type ())
#define CLASSIFIER_CASCADE_CLASSIFIER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CLASSIFIER_TYPE_CASCADE_CLASSIFIER, classifierCascadeClassifier))
#define CLASSIFIER_CASCADE_CLASSIFIER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CLASSIFIER_TYPE_CASCADE_CLASSIFIER, classifierCascadeClassifierClass))
#define CLASSIFIER_IS_CASCADE_CLASSIFIER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CLASSIFIER_TYPE_CASCADE_CLASSIFIER))
#define CLASSIFIER_IS_CASCADE_CLASSIFIER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CLASSIFIER_TYPE_CASCADE_CLASSIFIER))
#define CLASSIFIER_CASCADE_CLASSIFIER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CLASSIFIER_TYPE_CASCADE_CLASSIFIER, classifierCascadeClassifierClass))

typedef struct _classifierCascadeClassifier classifierCascadeClassifier;
typedef struct _classifierCascadeClassifierClass classifierCascadeClassifierClass;

#define GEOMETRY_TYPE_MAT (geometry_mat_get_type ())
#define GEOMETRY_MAT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEOMETRY_TYPE_MAT, geometryMat))
#define GEOMETRY_MAT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEOMETRY_TYPE_MAT, geometryMatClass))
#define GEOMETRY_IS_MAT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEOMETRY_TYPE_MAT))
#define GEOMETRY_IS_MAT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEOMETRY_TYPE_MAT))
#define GEOMETRY_MAT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEOMETRY_TYPE_MAT, geometryMatClass))

typedef struct _geometryMat geometryMat;
typedef struct _geometryMatClass geometryMatClass;

#define GEOMETRY_TYPE_MAT_OF_RECT (geometry_mat_of_rect_get_type ())
#define GEOMETRY_MAT_OF_RECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEOMETRY_TYPE_MAT_OF_RECT, geometryMatOfRect))
#define GEOMETRY_MAT_OF_RECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEOMETRY_TYPE_MAT_OF_RECT, geometryMatOfRectClass))
#define GEOMETRY_IS_MAT_OF_RECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEOMETRY_TYPE_MAT_OF_RECT))
#define GEOMETRY_IS_MAT_OF_RECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEOMETRY_TYPE_MAT_OF_RECT))
#define GEOMETRY_MAT_OF_RECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEOMETRY_TYPE_MAT_OF_RECT, geometryMatOfRectClass))

typedef struct _geometryMatOfRect geometryMatOfRect;
typedef struct _geometryMatOfRectClass geometryMatOfRectClass;
#define _g_free0(var) (var = (g_free (var), NULL))

struct _comfacedetectFaceDetectorInterfaceIface {
	GTypeInterface parent_iface;
	GeeList* (*detectFaces) (comfacedetectFaceDetectorInterface* self);
};

struct _comfacedetectstrategiesOpenCVFaceDetector {
	GObject parent_instance;
	comfacedetectstrategiesOpenCVFaceDetectorPrivate * priv;
};

struct _comfacedetectstrategiesOpenCVFaceDetectorClass {
	GObjectClass parent_class;
};

struct _comfacedetectstrategiesOpenCVFaceDetectorPrivate {
	GFile* image;
	GFile* templateList;
};


static gpointer com_facedetect_strategies_open_cv_face_detector_parent_class = NULL;
static comfacedetectFaceDetectorInterfaceIface * com_facedetect_strategies_open_cv_face_detector_com_facedetect_face_detector_interface_parent_iface = NULL;

GType com_facedetect_face_detector_interface_get_type (void) G_GNUC_CONST;
GType com_facedetect_strategies_open_cv_face_detector_get_type (void) G_GNUC_CONST;
#define COM_FACEDETECT_STRATEGIES_OPEN_CV_FACE_DETECTOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), COM_FACEDETECT_STRATEGIES_TYPE_OPEN_CV_FACE_DETECTOR, comfacedetectstrategiesOpenCVFaceDetectorPrivate))
comfacedetectstrategiesOpenCVFaceDetector* com_facedetect_strategies_open_cv_face_detector_new (GFile* image, GFile* templateList);
comfacedetectstrategiesOpenCVFaceDetector* com_facedetect_strategies_open_cv_face_detector_construct (GType object_type, GFile* image, GFile* templateList);
GType geometry_rectangle_get_type (void) G_GNUC_CONST;
static GeeList* com_facedetect_strategies_open_cv_face_detector_real_detectFaces (comfacedetectFaceDetectorInterface* base);
GType classifier_cascade_classifier_get_type (void) G_GNUC_CONST;
classifierCascadeClassifier* classifier_cascade_classifier_new (void);
classifierCascadeClassifier* classifier_cascade_classifier_construct (GType object_type);
GType geometry_mat_get_type (void) G_GNUC_CONST;
GType geometry_mat_of_rect_get_type (void) G_GNUC_CONST;
geometryMatOfRect* geometry_mat_of_rect_new (void);
geometryMatOfRect* geometry_mat_of_rect_construct (GType object_type);
GeeList* com_facedetect_strategies_open_cv_face_detector_listFiles (comfacedetectstrategiesOpenCVFaceDetector* self, GFile* file, const gchar* space, GCancellable* cancellable, GError** error);
geometryMat* imgcodecs_imgcodecs_imread (const gchar* filename);
gboolean classifier_cascade_classifier_load (classifierCascadeClassifier* self, const gchar* filename);
void classifier_cascade_classifier_detectMultiScale (classifierCascadeClassifier* self, geometryMat* image, geometryMatOfRect* objects);
geometryRectangle** geometry_mat_of_rect_toArray (geometryMatOfRect* self, int* result_length1);
gint geometry_rectangle_get_x (geometryRectangle* self);
gint geometry_rectangle_get_y (geometryRectangle* self);
gint geometry_rectangle_get_width (geometryRectangle* self);
gint geometry_rectangle_get_height (geometryRectangle* self);
geometryRectangle* geometry_rectangle_new_withBounds (gint x, gint y, gint width, gint height);
geometryRectangle* geometry_rectangle_construct_withBounds (GType object_type, gint x, gint y, gint width, gint height);
static void com_facedetect_strategies_open_cv_face_detector_finalize (GObject * obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


comfacedetectstrategiesOpenCVFaceDetector* com_facedetect_strategies_open_cv_face_detector_construct (GType object_type, GFile* image, GFile* templateList) {
	comfacedetectstrategiesOpenCVFaceDetector * self = NULL;
	GFile* _tmp0_;
	GFile* _tmp1_;
	GFile* _tmp2_;
	GFile* _tmp3_;
	g_return_val_if_fail (image != NULL, NULL);
	g_return_val_if_fail (templateList != NULL, NULL);
	self = (comfacedetectstrategiesOpenCVFaceDetector*) g_object_new (object_type, NULL);
	_tmp0_ = image;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->image);
	self->priv->image = _tmp1_;
	_tmp2_ = templateList;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->priv->templateList);
	self->priv->templateList = _tmp3_;
	return self;
}


comfacedetectstrategiesOpenCVFaceDetector* com_facedetect_strategies_open_cv_face_detector_new (GFile* image, GFile* templateList) {
	return com_facedetect_strategies_open_cv_face_detector_construct (COM_FACEDETECT_STRATEGIES_TYPE_OPEN_CV_FACE_DETECTOR, image, templateList);
}


static GeeList* com_facedetect_strategies_open_cv_face_detector_real_detectFaces (comfacedetectFaceDetectorInterface* base) {
	comfacedetectstrategiesOpenCVFaceDetector * self;
	GeeList* result = NULL;
	GeeList* rects = NULL;
	GeeArrayList* _tmp0_;
	classifierCascadeClassifier* faceDetector = NULL;
	classifierCascadeClassifier* _tmp1_;
	geometryMatOfRect* faceDetections = NULL;
	geometryMatOfRect* _tmp2_;
	GError * _inner_error_ = NULL;
	self = (comfacedetectstrategiesOpenCVFaceDetector*) base;
	_tmp0_ = gee_array_list_new (GEOMETRY_TYPE_RECTANGLE, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
	rects = (GeeList*) _tmp0_;
	_tmp1_ = classifier_cascade_classifier_new ();
	faceDetector = _tmp1_;
	_tmp2_ = geometry_mat_of_rect_new ();
	faceDetections = _tmp2_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				GeeList* _tmp5_ = NULL;
				GFile* _tmp6_;
				GCancellable* _tmp7_;
				GCancellable* _tmp8_;
				GeeList* _tmp9_;
				GeeList* _tmp10_;
				gint _tmp11_;
				gint _tmp12_;
				gint _tmp13_;
				geometryMat* image = NULL;
				GFile* _tmp14_;
				gchar* _tmp15_;
				gchar* _tmp16_;
				geometryMat* _tmp17_;
				geometryMat* _tmp18_;
				GeeList* _tmp19_ = NULL;
				GFile* _tmp20_;
				GCancellable* _tmp21_;
				GCancellable* _tmp22_;
				GeeList* _tmp23_;
				GeeList* _tmp24_;
				classifierCascadeClassifier* _tmp25_;
				gint _tmp26_;
				gpointer _tmp27_;
				gchar* _tmp28_;
				classifierCascadeClassifier* _tmp29_;
				geometryMat* _tmp30_;
				geometryMatOfRect* _tmp31_;
				geometryMatOfRect* _tmp32_;
				gint _tmp33_;
				geometryRectangle** _tmp34_;
				if (!_tmp3_) {
					gint _tmp4_;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp6_ = self->priv->templateList;
				_tmp7_ = g_cancellable_new ();
				_tmp8_ = _tmp7_;
				_tmp9_ = com_facedetect_strategies_open_cv_face_detector_listFiles (self, _tmp6_, "", _tmp8_, &_inner_error_);
				_tmp10_ = _tmp9_;
				_g_object_unref0 (_tmp8_);
				_tmp5_ = _tmp10_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_object_unref0 (faceDetections);
					_g_object_unref0 (faceDetector);
					_g_object_unref0 (rects);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
				_tmp11_ = i;
				_tmp12_ = gee_collection_get_size ((GeeCollection*) _tmp5_);
				_tmp13_ = _tmp12_;
				if (!(_tmp11_ < _tmp13_)) {
					_g_object_unref0 (_tmp5_);
					break;
				}
				_tmp14_ = self->priv->image;
				_tmp15_ = g_file_get_path (_tmp14_);
				_tmp16_ = _tmp15_;
				_tmp17_ = imgcodecs_imgcodecs_imread (_tmp16_);
				_tmp18_ = _tmp17_;
				_g_free0 (_tmp16_);
				image = _tmp18_;
				_tmp20_ = self->priv->templateList;
				_tmp21_ = g_cancellable_new ();
				_tmp22_ = _tmp21_;
				_tmp23_ = com_facedetect_strategies_open_cv_face_detector_listFiles (self, _tmp20_, "", _tmp22_, &_inner_error_);
				_tmp24_ = _tmp23_;
				_g_object_unref0 (_tmp22_);
				_tmp19_ = _tmp24_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_object_unref0 (image);
					_g_object_unref0 (_tmp5_);
					_g_object_unref0 (faceDetections);
					_g_object_unref0 (faceDetector);
					_g_object_unref0 (rects);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
				_tmp25_ = faceDetector;
				_tmp26_ = i;
				_tmp27_ = gee_list_get (_tmp19_, _tmp26_);
				_tmp28_ = (gchar*) _tmp27_;
				classifier_cascade_classifier_load (_tmp25_, _tmp28_);
				_g_free0 (_tmp28_);
				_tmp29_ = faceDetector;
				_tmp30_ = image;
				_tmp31_ = faceDetections;
				classifier_cascade_classifier_detectMultiScale (_tmp29_, _tmp30_, _tmp31_);
				_tmp32_ = faceDetections;
				_tmp34_ = geometry_mat_of_rect_toArray (_tmp32_, &_tmp33_);
				{
					geometryRectangle** rect_collection = NULL;
					gint rect_collection_length1 = 0;
					gint _rect_collection_size_ = 0;
					gint rect_it = 0;
					rect_collection = _tmp34_;
					rect_collection_length1 = _tmp33_;
					for (rect_it = 0; rect_it < _tmp33_; rect_it = rect_it + 1) {
						geometryRectangle* _tmp35_;
						geometryRectangle* rect = NULL;
						_tmp35_ = _g_object_ref0 (rect_collection[rect_it]);
						rect = _tmp35_;
						{
							GeeList* _tmp36_;
							geometryRectangle* _tmp37_;
							gint _tmp38_;
							gint _tmp39_;
							geometryRectangle* _tmp40_;
							gint _tmp41_;
							gint _tmp42_;
							geometryRectangle* _tmp43_;
							gint _tmp44_;
							gint _tmp45_;
							geometryRectangle* _tmp46_;
							gint _tmp47_;
							gint _tmp48_;
							geometryRectangle* _tmp49_;
							geometryRectangle* _tmp50_;
							_tmp36_ = rects;
							_tmp37_ = rect;
							_tmp38_ = geometry_rectangle_get_x (_tmp37_);
							_tmp39_ = _tmp38_;
							_tmp40_ = rect;
							_tmp41_ = geometry_rectangle_get_y (_tmp40_);
							_tmp42_ = _tmp41_;
							_tmp43_ = rect;
							_tmp44_ = geometry_rectangle_get_width (_tmp43_);
							_tmp45_ = _tmp44_;
							_tmp46_ = rect;
							_tmp47_ = geometry_rectangle_get_height (_tmp46_);
							_tmp48_ = _tmp47_;
							_tmp49_ = geometry_rectangle_new_withBounds (_tmp39_, _tmp42_, _tmp45_, _tmp48_);
							_tmp50_ = _tmp49_;
							gee_collection_add ((GeeCollection*) _tmp36_, _tmp50_);
							_g_object_unref0 (_tmp50_);
							_g_object_unref0 (rect);
						}
					}
					rect_collection = (_vala_array_free (rect_collection, rect_collection_length1, (GDestroyNotify) g_object_unref), NULL);
				}
				_g_object_unref0 (_tmp19_);
				_g_object_unref0 (image);
				_g_object_unref0 (_tmp5_);
			}
		}
	}
	result = rects;
	_g_object_unref0 (faceDetections);
	_g_object_unref0 (faceDetector);
	return result;
}


GeeList* com_facedetect_strategies_open_cv_face_detector_listFiles (comfacedetectstrategiesOpenCVFaceDetector* self, GFile* file, const gchar* space, GCancellable* cancellable, GError** error) {
	GeeList* result = NULL;
	GFileEnumerator* enumerator = NULL;
	GFile* _tmp0_;
	GCancellable* _tmp1_;
	GFileEnumerator* _tmp2_;
	GFileInfo* info = NULL;
	GeeArrayList* filePaths = NULL;
	GeeArrayList* _tmp3_;
	GCancellable* _tmp19_;
	gboolean _tmp20_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (file != NULL, NULL);
	g_return_val_if_fail (space != NULL, NULL);
	_tmp0_ = file;
	_tmp1_ = cancellable;
	_tmp2_ = g_file_enumerate_children (_tmp0_, "standard::*", G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, _tmp1_, &_inner_error_);
	enumerator = _tmp2_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		return NULL;
	}
	info = NULL;
	_tmp3_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, NULL, NULL, NULL);
	filePaths = _tmp3_;
	while (TRUE) {
		gboolean _tmp4_ = FALSE;
		GCancellable* _tmp5_;
		gboolean _tmp6_;
		GFileInfo* _tmp13_;
		GFileType _tmp14_;
		_tmp5_ = cancellable;
		_tmp6_ = g_cancellable_is_cancelled (_tmp5_);
		if (_tmp6_ == FALSE) {
			GFileInfo* _tmp7_ = NULL;
			GFileEnumerator* _tmp8_;
			GCancellable* _tmp9_;
			GFileInfo* _tmp10_;
			GFileInfo* _tmp11_;
			GFileInfo* _tmp12_;
			_tmp8_ = enumerator;
			_tmp9_ = cancellable;
			_tmp10_ = g_file_enumerator_next_file (_tmp8_, _tmp9_, &_inner_error_);
			_tmp7_ = _tmp10_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				g_propagate_error (error, _inner_error_);
				_g_object_unref0 (filePaths);
				_g_object_unref0 (info);
				_g_object_unref0 (enumerator);
				return NULL;
			}
			_tmp11_ = _tmp7_;
			_tmp7_ = NULL;
			_g_object_unref0 (info);
			info = _tmp11_;
			_tmp12_ = info;
			_tmp4_ = _tmp12_ != NULL;
			_g_object_unref0 (_tmp7_);
		} else {
			_tmp4_ = FALSE;
		}
		if (!_tmp4_) {
			break;
		}
		_tmp13_ = info;
		_tmp14_ = g_file_info_get_file_type (_tmp13_);
		if (_tmp14_ != G_FILE_TYPE_DIRECTORY) {
			gchar* path = NULL;
			GFile* _tmp15_;
			gchar* _tmp16_;
			GeeArrayList* _tmp17_;
			const gchar* _tmp18_;
			_tmp15_ = file;
			_tmp16_ = g_file_get_path (_tmp15_);
			path = _tmp16_;
			_tmp17_ = filePaths;
			_tmp18_ = path;
			gee_abstract_collection_add ((GeeAbstractCollection*) _tmp17_, _tmp18_);
			_g_free0 (path);
		}
	}
	_tmp19_ = cancellable;
	_tmp20_ = g_cancellable_is_cancelled (_tmp19_);
	if (_tmp20_) {
		GError* _tmp21_;
		_tmp21_ = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_CANCELLED, "Operation was cancelled");
		_inner_error_ = _tmp21_;
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (filePaths);
		_g_object_unref0 (info);
		_g_object_unref0 (enumerator);
		return NULL;
	}
	result = (GeeList*) filePaths;
	_g_object_unref0 (info);
	_g_object_unref0 (enumerator);
	return result;
}


static void com_facedetect_strategies_open_cv_face_detector_class_init (comfacedetectstrategiesOpenCVFaceDetectorClass * klass) {
	com_facedetect_strategies_open_cv_face_detector_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (comfacedetectstrategiesOpenCVFaceDetectorPrivate));
	G_OBJECT_CLASS (klass)->finalize = com_facedetect_strategies_open_cv_face_detector_finalize;
}


static void com_facedetect_strategies_open_cv_face_detector_com_facedetect_face_detector_interface_interface_init (comfacedetectFaceDetectorInterfaceIface * iface) {
	com_facedetect_strategies_open_cv_face_detector_com_facedetect_face_detector_interface_parent_iface = g_type_interface_peek_parent (iface);
	iface->detectFaces = (GeeList* (*) (comfacedetectFaceDetectorInterface *)) com_facedetect_strategies_open_cv_face_detector_real_detectFaces;
}


static void com_facedetect_strategies_open_cv_face_detector_instance_init (comfacedetectstrategiesOpenCVFaceDetector * self) {
	self->priv = COM_FACEDETECT_STRATEGIES_OPEN_CV_FACE_DETECTOR_GET_PRIVATE (self);
}


static void com_facedetect_strategies_open_cv_face_detector_finalize (GObject * obj) {
	comfacedetectstrategiesOpenCVFaceDetector * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, COM_FACEDETECT_STRATEGIES_TYPE_OPEN_CV_FACE_DETECTOR, comfacedetectstrategiesOpenCVFaceDetector);
	_g_object_unref0 (self->priv->image);
	_g_object_unref0 (self->priv->templateList);
	G_OBJECT_CLASS (com_facedetect_strategies_open_cv_face_detector_parent_class)->finalize (obj);
}


GType com_facedetect_strategies_open_cv_face_detector_get_type (void) {
	static volatile gsize com_facedetect_strategies_open_cv_face_detector_type_id__volatile = 0;
	if (g_once_init_enter (&com_facedetect_strategies_open_cv_face_detector_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (comfacedetectstrategiesOpenCVFaceDetectorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) com_facedetect_strategies_open_cv_face_detector_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (comfacedetectstrategiesOpenCVFaceDetector), 0, (GInstanceInitFunc) com_facedetect_strategies_open_cv_face_detector_instance_init, NULL };
		static const GInterfaceInfo com_facedetect_face_detector_interface_info = { (GInterfaceInitFunc) com_facedetect_strategies_open_cv_face_detector_com_facedetect_face_detector_interface_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType com_facedetect_strategies_open_cv_face_detector_type_id;
		com_facedetect_strategies_open_cv_face_detector_type_id = g_type_register_static (G_TYPE_OBJECT, "comfacedetectstrategiesOpenCVFaceDetector", &g_define_type_info, 0);
		g_type_add_interface_static (com_facedetect_strategies_open_cv_face_detector_type_id, COM_FACEDETECT_TYPE_FACE_DETECTOR_INTERFACE, &com_facedetect_face_detector_interface_info);
		g_once_init_leave (&com_facedetect_strategies_open_cv_face_detector_type_id__volatile, com_facedetect_strategies_open_cv_face_detector_type_id);
	}
	return com_facedetect_strategies_open_cv_face_detector_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



